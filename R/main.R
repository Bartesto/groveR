# Main functions

#' A function to turn vegetation index raster data into a vegetation density
#' raster for further analysis.
#'
#' \code{veg_dens} takes an annual series of vegetation index rasters and
#'     converts them to a vegetation density (cover) product.
#'
#' @details Density to vegetation index relationship must be established through
#'     prior analysis and the calibration file will provide the coefficients
#'     from this. The calibration file is a simple csv with a value in 5 columns
#'     named as follows:
#' \itemize{
#'   \item coef - the coefficient of the regression
#'   \item intercept -  the intercept of the regression
#'   \item multiple - a value to multiply by to bring output to a percentage
#'   \item lower - lower limit of acceptable vegetation density
#'   \item upper - upper limit of acceptable vegetation density
#' }
#'    All input rasters should have the same extents and cell size. Whilst it
#'    won't affect the performance of this function, downstream processing will
#'    fail. See package vignette for full explanation of processing work flow.
#'
#' @param irast Character file path to input vegetation index rasters.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param choice Character vector of chosen year/s. If all years in a folder are
#'     to be processed choice can be "all".
#' @param index Character representation of the index (should be part of the
#'     input raster file name) which will be replaced in the new output file name.
#' @param ext Character representation of the desired file type output. Prefer
#'     ".img" to avoid missing crs information.
#' @param calibration Character representation of the name of the calibration
#'     csv file including file path.
#'
#' @return For each input raster a vegetation density raster of the same will be
#'     written to file in a folder named `veg_dens/`.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' veg_dens(irast = "Z:/DEC/projectXX/mosaics", rastkey = ".ers",
#'     choice = c("1991", "2010"), index = "ndvi", ext = ".img",
#'     calibration = "./supplementary/calibration.csv")
#'     }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls
#' @importFrom stringr str_replace
#' @importFrom readr parse_number read_csv
#' @importFrom raster raster overlay writeRaster
#'
#' @export

veg_dens <- function(irast, rastkey, choice, index, ext, calibration){
  suppressWarnings({
    # rasters to process
    if(choice == "all"){
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey, "$"))) %>%
        dplyr::mutate(bname = stringr::str_replace(basename(path), index,
                                                   "V_Dens"))
    } else {
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey, "$"))) %>%
        dplyr::mutate(yr = readr::parse_number(basename(path))) %>%
        dplyr::filter(yr %in% choice) %>%
        dplyr::mutate(bname = stringr::str_replace(basename(path), index,
                                                   "V_Dens")) %>%
        dplyr::select(-yr)
    }
    # calibration file
    calib <- readr::read_csv(calibration)
    # cover formula
    coef <- calib[["coef"]]
    intercept <- calib[["intercept"]]
    multiple <- calib[["multiple"]]
    vdens <- function(x) (((x * coef) + intercept) * multiple)
    # output folder
    out <- "./veg_dens"
    if (!file.exists(out)) {dir.create(out)}
    # process rasters
    for(i in seq_along(rastdf[[1]])){
      ir1 <- raster::raster(rastdf[['path']][i])
      cat("Calculating vegetation density..." , basename(rastdf[[1]][i]), "\n")
      # apply functions per pixel
      ir2 <- raster::overlay(ir1, fun = vdens)
      # clean
      ir2[ir2 < calib[["lower"]]] <- NA
      ir2[ir2 > calib[["upper"]]] <- NA
      # write output to file
      fname <- paste0(out, "/", rastdf[['bname']][i])
      # change extension
      fname <- gsub(tools::file_ext(fname), tools::file_ext(ext), fname)
      raster::writeRaster(ir2, filename = fname,
                          overwrite = TRUE, options=c('OVR=YES'))
    }
  })
}

#' A function to apply common masks to rasters
#'
#' \code{mask_product} takes one or multiple input rasters and applies
#'     pre-generated masks to exclude areas or clean up rasters.
#'
#' @details When producing raster products for an area there are often regions
#'     that occur at any time step that are not required for further analysis.
#'     Things like water bodies or non-target vegetation are examples. A folder
#'     full of different raster masks can be applied with this function.
#'
#'     Raster masks are a binary raster indicating spatially where values of
#'     interest are but can be created with the intent to include or exclude. If
#'     a mask is designed to be used in an inverse manner then "INV" should be
#'     included in its file name. The function will search for these letters and
#'     reverse the mask accordingly.
#'
#' @param irast Character file path to directory veg density input rasters.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param choice Character vector of chosen year/s. If all years in a folder are
#'     to be processed choice can be "all".
#' @param imask Character file path to directory of raster masks to apply.
#' @param maskkey Character representation of the file extension of the raster
#'     masks.
#'
#' @return For each input raster a masked product will be written to file in a
#'     folder named `veg_dens_mskd/`. Masked values will be NA.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' mask_product(irast = "./veg_dens", rastkey = ".tif", choice = "all",
#'     imask = "Z:/DEC/projectXX/processing/raster_masks", maskkey = ".img")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls
#' @importFrom stringr str_replace str_detect
#' @importFrom readr parse_number
#' @importFrom raster raster mask writeRaster
#'
#' @export
mask_product <- function(irast, rastkey, choice, imask, maskkey){
  suppressWarnings({
    if(choice == "all"){
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey, "$"))) %>%
        dplyr::mutate(bname = stringr::str_replace(basename(path), "Dens",
                                                   "Dens_Mskd"))
    } else {
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey, "$"))) %>%
        dplyr::mutate(yr = readr::parse_number(basename(path))) %>%
        dplyr::filter(yr %in% choice) %>%
        dplyr::mutate(bname = stringr::str_replace(basename(path), "Dens",
                                                   "Dens_Mskd"))
    }
    maskdf <- dplyr::tibble(path = fs::dir_ls(imask,
                                              glob = paste0("*",
                                                            maskkey, "$"))) %>%
      dplyr::mutate(inverse = stringr::str_detect(basename(path), "INV"))
    # output folder
    out <- "./veg_dens_mskd"
    if (!file.exists(out)) {dir.create(out)}
    for(i in seq_along(rastdf[[1]])){
      ir1 <-  raster::raster(rastdf[[1]][i])
      cat("Masking...", basename(rastdf[[1]][i]), "\n")
      for(j in seq_along(maskdf[[1]])){
        m <- raster::raster(maskdf[[1]][j])
        if(maskdf[['inverse']][j] == FALSE){
          ir1 <- raster::mask(ir1, m)
        } else {
          ir1 <- raster::mask(ir1, m, inverse = TRUE)
        }
      }
      mskdname <- paste0(out, "/", rastdf[['bname']][i])
      raster::writeRaster(ir1, filename = mskdname, overwrite = TRUE,
                          options=c('OVR=YES'))
    }
  })
}

#' A function to apply cloud masks to rasters in bulk.
#'
#' \code{cloud_mask_bulk} takes multiple input rasters and applies
#'     pre-generated masks to exclude areas or clean up rasters in select
#'     input rasters only.
#'
#' @details The "cloud_mask" form of functions, apply a pre-generated mask to
#'     a single raster. These masks are often for things like cloud and shadow
#'     but could include something like a fire scar that could throw out the
#'     calibration to vegetation density. These circumstances are pertinent to
#'     one time step only, so the masks used here will be matched to the correct
#'     input by a year in the file name.
#'
#'     This function is designed to sort through a complete time series of input
#'     rasters and work out which need masking based on the presence of masks in
#'     a separate directory.
#'
#'     The function will compare any newly masked rasters to the raster of
#'     the year before in order to clean up masked areas that might extend over
#'     water for example. Masked areas in the product have a value of -99 and
#'     this step ensures that previously "NA" masked areas don't now have a -99
#'     value.
#'
#'     Masking of the very first input raster of a time series is handled without
#'     this step as there is no prior image to compare to. Any input raster with
#'     no requirement for masking is renamed and copied to the output directory.
#'
#'     It is vital that all input rasters and masks have the same extents, CRS
#'     and cell size.
#'
#' @param irast Character file path to directory of input rasters, most commonly,
#'     those created by \code{link{mask_product}} and stored at
#'     `veg_dens_mskd/`.
#' @param rastkey Character representation of unique string to match the intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param imask Character file path to directory of cloud raster masks to
#'     apply. Commonly something like "raster_masks/cloud_masks/".
#' @param maskkey Character representation of the file extension of the raster
#'     masks.
#'
#' @return Any cloud masking will carried out to affected input rasters and
#'     these will be written to `veg_dens_mskd_cld/`. cloud masked
#'     areas will have a -99 value.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' cloud_mask_bulk(irast = "./veg_dens_mskd", rastkey = ".tif",
#'     imask = "Z:/DEC/projectXX/processing/raster_masks/cloud_masks",
#'     maskkey = ".ers")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls file_copy
#' @importFrom stringr str_replace
#' @importFrom readr parse_number
#' @importFrom raster raster mask maxValue writeRaster cover overlay stack
#'
#' @export
cloud_mask_bulk <- function(irast, rastkey, imask, maskkey){
  suppressWarnings({
    rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                              glob = paste0("*",
                                                            rastkey, "$"))) %>%
      dplyr::mutate(pathnew = stringr::str_replace(path, "mskd",
                                                   "mskd_cld"),
                    pathnew = stringr::str_replace(pathnew, "Mskd",
                                                   "MskdCld"),
                    year = readr::parse_number(basename(path)))
    maskdf <- dplyr::tibble(path = fs::dir_ls(imask,
                                              glob = paste0("*",
                                                            maskkey, "$"))) %>%
      dplyr::mutate(year = readr::parse_number(basename(path)))

    jdf <- dplyr::left_join(rastdf, maskdf, by = "year") %>%
      dplyr::mutate(cloud = !is.na(path.y))
    # output folder
    out <- "./veg_dens_mskd_cld"
    if (!file.exists(out)) {dir.create(out)}
    if(jdf$cloud[[1]] == TRUE){
      # deal with first of time series having clouds but no prior year reference image
      s_rast <- raster::raster(jdf[[1]][1])
      c_rast <- raster::raster(jdf[[4]][1])
      cat("Masking...", basename(jdf[[1]][1]), "\n")
      # find mask val
      cmax <- raster::maxValue(c_rast)
      c_rast[c_rast == cmax] <- - 99 #make -99 so outside allowable limits for veg dens
      o_rast <- raster::cover(c_rast, s_rast)
      raster::writeRaster(x = o_rast, filename = jdf[[2]][1], overwrite=TRUE)

      # deal with non- cloud affected images (i.e. just rename and move)
      cat("Copying and renaming unaffected images...",  "\n")
      copydf <- jdf %>%
        dplyr::filter(cloud == FALSE)
      fs::file_copy(copydf[[1]], copydf[[2]], overwrite=TRUE)

      # deal with cloud and prior reference image
      # function for later
      cldfun = function(x1, x2){
        ifelse(is.na(x1) & is.na(x2), NA,
               ifelse(x2 == -99 & is.na(x1), x1, x2))}
      # a df without first image
      jdf_short <- jdf %>%
        dplyr::slice(-1)
      # a character string of cloudy years
      cloud_yrs <- jdf_short %>%
        dplyr::filter(cloud == TRUE) %>%
        dplyr::pull(year)

      for(i in seq_along(cloud_yrs)){
        # cloudy year
        yr <- cloud_yrs[i]
        # cloudy image name
        c_im <- jdf_short %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.x)
        cat("Masking images with reference images...", basename(c_im), "\n")
        # prior image name
        p_im <- jdf_short %>%
          dplyr::filter(year == yr-1) %>%
          dplyr::pull(path.x)
        # cloudy mask name
        cs_n <- jdf_short %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.y)
        # cloudy mask
        cs_msk <- raster::raster(cs_n)
        csmax <- raster::maxValue(cs_msk)
        # cloudy raster to do, put in cloud
        c_rst <- raster::raster(c_im)
        cs_msk[cs_msk == csmax] <- - 99 # turn user mask vals to -99
        o_rst <- raster::cover( cs_msk, c_rst)
        # bring in prior image
        p_rst <- raster::raster(p_im)
        st <- raster::stack(p_rst, o_rst)
        # now clean up based on prior image
        clean_rst <- raster::overlay(st, fun = cldfun)
        # new name
        n_n <- jdf_short %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(pathnew)
        raster::writeRaster(clean_rst, filename = n_n, overwrite = TRUE,
                            options=c('OVR=YES'))
      }
    } else{
      # deal with non- cloud affected images (i.e. just rename and move)
      cat("Copying and renaming unaffected images...",  "\n")
      copydf <- jdf %>%
        dplyr::filter(cloud == FALSE)
      fs::file_copy(copydf[[1]], copydf[[2]], overwrite=TRUE)

      # deal with cloud and prior reference image
      # function for later
      cldfun = function(x1, x2){
        ifelse(is.na(x1) & is.na(x2), NA,
               ifelse(x2 == -99 & is.na(x1), x1, x2))}
      # clouds years left to do
      cloud_yrs <- jdf %>%
        dplyr::filter(cloud == TRUE) %>%
        dplyr::pull(year)

      for(i in seq_along(cloud_yrs)){
        # cloudy year
        yr <- cloud_yrs[i]
        # cloudy image name
        c_im <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.x)
        cat("Masking images with reference images...", basename(c_im), "\n")
        # prior image name
        p_im <- jdf%>%
          dplyr::filter(year == yr-1) %>%
          dplyr::pull(path.x)
        # cloudy mask name
        cs_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.y)
        # cloudy mask
        cs_msk <- raster::raster(cs_n)
        csmax <- raster::maxValue(cs_msk)
        # cloudy raster to do, put in cloud
        c_rst <- raster::raster(c_im)
        cs_msk[cs_msk == csmax] <- - 99
        o_rst <- raster::cover(cs_msk, c_rst)
        # bring in prior image
        p_rst <- raster::raster(p_im)
        st <- raster::stack(p_rst, o_rst)
        # now clean up based on prior image
        clean_rst <- raster::overlay(st, fun = cldfun)
        # new name
        n_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(pathnew)
        raster::writeRaster(clean_rst, filename = n_n, overwrite = TRUE,
                            options=c('OVR=YES'))
      }
    }
  })
}

#' A function to apply cloud masks to one or a selection of rasters.
#'
#' \code{cloud_mask_select} takes multiple input rasters and applies
#'     pre-generated masks to exclude areas or clean up rasters in selected
#'     input rasters only.
#'
#' @details The "cloud_mask" form of functions, apply a pre-generated mask to
#'     a single raster. These masks are often for things like cloud and shadow
#'     but could include something like a fire scar that could throw out the
#'     calibration to vegetation density. These circumstances are pertinent to
#'     one time step only, so the masks used here will be matched to the correct
#'     input by a year in the file name.
#'
#'     This function is designed to sort through a complete time series of input
#'     rasters and apply masks to only those selected.
#'
#'     The function will compare any newly masked rasters to the raster of
#'     the year before in order to clean up masked areas that might extend over
#'     water for example. Masked areas in the product have a value of -99 and
#'     this step ensures that previously "NA" masked areas don't now have a -99
#'     value.
#'
#'     Masking of the very first input raster of a time series is handled without
#'     this step as there is no prior image to compare to. Any input raster with
#'     no requirement for masking is renamed and copied to the output directory.
#'
#'     It is vital that all input rasters and masks have the same extents, CRS
#'     and cell size.
#'
#' @inheritParams cloud_mask_bulk
#' @param choice A character vector of year/s to mask.
#'
#' @return Any cloud masking will carried out to affected input rasters and
#'     these will be written to `veg_dens_mskd_cld/`. cloud masked
#'     areas will have a -99 value.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' cloud_mask_select(irast = "./veg_dens_mskd", rastkey = ".tif",
#'     imask = "Z:/DEC/projectXX/processing/raster_masks/cloud_masks",
#'     maskkey = ".ers", choice = c("2011", "2015"))
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls file_copy
#' @importFrom stringr str_replace
#' @importFrom readr parse_number
#' @importFrom raster raster mask maxValue writeRaster cover overlay stack
#'
#' @export
cloud_mask_select <- function(irast, rastkey, choice, imask, maskkey){
  suppressWarnings({
    rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                              glob = paste0("*",
                                                            rastkey, "$"))) %>%
      dplyr::mutate(pathnew = stringr::str_replace(path, "mskd",
                                                   "mskd_cld"),
                    pathnew = stringr::str_replace(pathnew, "Mskd",
                                                   "MskdCld"),
                    year = readr::parse_number(basename(path)))
    maskdf <- dplyr::tibble(path = fs::dir_ls(imask,
                                              glob = paste0("*",
                                                            maskkey, "$"))) %>%
      dplyr::mutate(year = readr::parse_number(basename(path))) %>%
      dplyr::filter(year %in% choice)
    jdf <- dplyr::left_join(rastdf, maskdf, by = "year") %>%
      dplyr::mutate(cloud = !is.na(path.y))
    cldfun <- function(x1, x2){
      ifelse(is.na(x1) & is.na(x2), NA,
             ifelse(x2 == -99 & is.na(x1), x1, x2))}
    # output folder
    out <- "./veg_dens_mskd_cld"
    if (!file.exists(out)) {dir.create(out)}
    for(i in seq_along(choice)){
      yr1 <- jdf[[3]][1]
      cloudyr1 <- jdf[[5]][1]
      cdata <- jdf %>%
        dplyr::filter(year == as.numeric(choice[i])) %>%
        dplyr::pull(cloud)
      if(choice[i] == yr1 & cloudyr1 == TRUE){
        # deal with first of time series having clouds but no prior year reference image
        s_rast <- raster::raster(jdf[[1]][1])
        c_rast <- raster::raster(jdf[[4]][1])
        cat("Masking...", basename(jdf[[1]][1]), "\n")
        # find mask val
        cmax <- raster::maxValue(c_rast)
        c_rast[c_rast == cmax] <- - 99 #make -99 so outside allowable limits for veg dens
        o_rast <- raster::cover(c_rast, s_rast)
        raster::writeRaster(x = o_rast, filename = jdf[[2]][1], overwrite=TRUE)
      } else if(choice[i] != yr1 & cdata == FALSE){
        # deal with non- cloud affected images (i.e. just rename and move)
        cat("Copying and renaming unaffected image...",  "\n")
        copydf <- jdf %>%
          dplyr::filter(year == choice[i])
        fs::file_copy(copydf[[1]], copydf[[2]], overwrite=TRUE)
      } else if(choice[i] != yr1 & cdata == TRUE){
        yr <- as.numeric(choice[i])
        # cloudy image name
        c_im <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.x)
        cat("Masking images with reference images...", basename(c_im), "\n")
        # prior image name
        p_im <- jdf %>%
          dplyr::filter(year == yr-1) %>%
          dplyr::pull(path.x)
        # cloudy mask name
        cs_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.y)
        # cloudy mask
        cs_msk <- raster::raster(cs_n)
        csmax <- raster::maxValue(cs_msk)
        # cloudy raster to do, put in cloud
        c_rst <- raster::raster(c_im)
        cs_msk[cs_msk == csmax] <- - 99
        o_rst <- raster::cover(cs_msk, c_rst)
        # bring in prior image
        p_rst <- raster::raster(p_im)
        st <- raster::stack(p_rst, o_rst)
        # now clean up based on prior image
        clean_rst <- raster::overlay(st, fun = cldfun)
        # new name
        n_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(pathnew)
        raster::writeRaster(clean_rst, filename = n_n, overwrite = TRUE,
                            options=c('OVR=YES'))
      }

    }

  })
}

#' A function to perform vegetation classifications
#'
#' \code{veg_class} performs a raster reclassification based on a user supplied
#'     set of meaningful bins.
#'
#' @details This function is designed to take the continuous values, in say a
#'     raster of vegetation densities, and convert them to numeric classes based
#'     on some prior determination. The user must supply a csv of density
#'     classes with the following three column format so that each row forms a
#'     bin:
#' \itemize{
#'   \item lower - numerical low value for bin
#'   \item upper - numerical high value (<=) for bin
#'   \item reclass - numerical classification value
#'   }
#'
#'    The numerical classification can take any single integer value except
#'    6. The integer 6 is reserved for any values that had a masked value of -99
#'    created by using the "cloud_mask" functions.
#'
#'    The function can also perform some "probable" value classification in
#'    areas that are masked with a -99 value. It will identify the same pixels
#'    in the previous year's raster and return those classified values plus 10.
#'    The reasoning here is that those pixels possibly would not have changed
#'    density but they can still be identified and removed (e.g. any value > 10)
#'    in downstream analysis.
#'
#' @param irast Character file path to input veg density rasters that have been
#'     through the masking process, i.e. those that are found in
#'     `veg_dens_mskd\` or `veg_dens_mskd_cld\`.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param imask A character file path to directory of raster masks that were
#'     created using a "cloud_mask" function if a "probable" classification is
#'     desired. If there were none or you would prefer that no "probable"
#'     classifications be carried out use FALSE.
#' @param maskkey Character representation of the file extension of the raster
#'     masks if a "probable" classification is desired. If not use NA
#' @param classes Character representation of the name of the density classes
#'     csv file including file path.
#'
#' @return All input rasters will be reclassified and be written to either
#'     `veg_class_cloud_prob/` for "probable" classifications or `veg_class/` if
#'     standard classifications are carried out.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' veg_class(irast = "./veg_dens_mskd", rastkey = ".tif",
#'     imask = FALSE, maskkey = NA,
#'     classes = "./supplementary/density_classes.csv")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls file_copy
#' @importFrom stringr str_replace
#' @importFrom readr parse_number read_csv
#' @importFrom raster raster writeRaster reclassify stack overlay
#'
#' @export
veg_class <- function(irast, rastkey, imask, maskkey, classes){
  suppressWarnings({
    # get classes
    if(file.exists(classes) == FALSE) stop("classes csv must exist")
    cl <- as.matrix(readr::read_csv(classes))
    if(dim(cl)[2] !=3) stop("check that classes csv has 3 columns")
    # dealing with first image cloudy?
    if(imask == FALSE){
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey,
                                                              "$"))) %>%
        dplyr::mutate(pathnew = stringr::str_replace(path, "dens_mskd",
                                                     "class"),
                      pathnew = stringr::str_replace(pathnew, "V_Dens_Mskd",
                                                     "Veg_Class"),
                      year = readr::parse_number(basename(path)))

      maskdf <- dplyr::tibble(path = NA, year = NA)

    } else {
      rastdf <- dplyr::tibble(path = fs::dir_ls(irast,
                                                glob = paste0("*",
                                                              rastkey,
                                                              "$"))) %>%
        dplyr::mutate(pathnew = stringr::str_replace(path, "dens_mskd_cld",
                                                     "class_cloud_prob"),
                      pathnew = stringr::str_replace(pathnew, "V_Dens_MskdCld",
                                                     "Veg_Class_Cloud_Probabilities"),
                      year = readr::parse_number(basename(path)))

      maskdf <- dplyr::tibble(path = fs::dir_ls(imask,
                                                glob = paste0("*",
                                                              maskkey, "$"))) %>%
        dplyr::mutate(year = readr::parse_number(basename(path)))
    }

    jdf <- dplyr::left_join(rastdf, maskdf, by = "year") %>%
      dplyr::mutate(cloud = !is.na(path.y))

    if(imask == FALSE){
      out <- "./veg_class"
    } else {
      out <- "./veg_class_cloud_prob"
    }
    if (!file.exists(out)) {dir.create(out)}
    if(jdf$cloud[[1]] == TRUE){
      # deal with first of time series having clouds but no prior year reference image
      s_rast <- raster::raster(jdf[[1]][1])
      cat("Classifying...", basename(jdf[[1]][1]), "\n")
      rcl <- raster::reclassify(s_rast, cl)
      # grab a non cloudy to effect some masking
      nci <- jdf %>%
        dplyr::filter(cloud == FALSE) %>%
        dplyr::pull(path.x)
      nci <- nci[1]
      nci_rst <- raster::raster(nci)
      st <- raster::stack(nci, rcl)
      mskfun = function(x1, x2){
        ifelse(x2 == 6 & is.na(x1), NA, x2)
      }
      cl_rst <- raster::overlay(st, fun = mskfun)

      raster::writeRaster(x = cl_rst, filename = jdf[[2]][1], datatype = 'INT1U',
                          overwrite=TRUE)

      # classify non cloud affected images
      jdf2 <- jdf %>%
        dplyr::filter(cloud == FALSE)
      for(i in seq_along(jdf2[[1]])){
        cat("Classifying...", basename(jdf2[[1]][i]), "\n")
        rst <- raster::raster(jdf2[[1]][i])
        rcl <- raster::reclassify(rst, cl)
        raster::writeRaster(x = rcl, filename = jdf2[[2]][i], datatype = 'INT1U',
                            overwrite=TRUE)
      }
      # classify cloudy using previous image
      # a df without first image
      jdf_short <- jdf %>%
        dplyr::slice(-1)#important for when first image is cloudy
      cloud_yrs <- jdf_short %>%
        dplyr::filter(cloud == TRUE) %>%
        dplyr::pull(year)
      # function for later
      cldfun2 = function(x1, x2){
        ifelse(is.na(x1) & is.na(x2), NA,
               ifelse(x2 == 6 & is.na(x1), x1,
                      ifelse(x2 == 6 & !is.na(x1), x1 + 10, x2)))}
      for(j in seq_along(cloud_yrs)){
        yr <- cloud_yrs[j]
        c_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.x)
        cat("Classifying...", basename(c_n), "\n")
        p_n <- jdf %>%
          dplyr::filter(year == yr - 1) %>%
          dplyr::pull(pathnew)#bring in classified image
        # current cloudy raster
        c_rst <- raster::raster(c_n)
        # classify it
        c_rst_c <- raster::reclassify(c_rst, cl)
        # previously already classified yr
        p_rst <- raster::raster(p_n)
        # stack it
        st <- raster::stack(p_rst, c_rst_c)
        # now clean up based on prior image
        clean_rst <- raster::overlay(st, fun = cldfun2)
        o_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(pathnew)
        raster::writeRaster(x = clean_rst, filename = o_n, datatype = "INTU",
                            overwrite = TRUE)
      }

    } else {
      # no cloudy first image so move straight on
      # classify non cloud affected images
      jdf2 <- jdf %>%
        dplyr::filter(cloud == FALSE)
      for(i in seq_along(jdf2[[1]])){
        cat("Classifying...", basename(jdf2[[1]][i]), "\n")
        rst <- raster::raster(jdf2[[1]][i])
        rcl <- raster::reclassify(rst, cl)
        raster::writeRaster(x = rcl, filename = jdf2[[2]][i], datatype = 'INT1U',
                            overwrite=TRUE)
      }
      # classify cloudy using previous image
      cloud_yrs <- jdf %>%
        dplyr::filter(cloud == TRUE) %>%
        dplyr::pull(year)
      # function for later
      cldfun2 = function(x1, x2){
        ifelse(is.na(x1) & is.na(x2), NA,
               ifelse(x2 == 6 & is.na(x1), x1,
                      ifelse(x2 == 6 & !is.na(x1), x1 + 10, x2)))}
      for(j in seq_along(cloud_yrs)){
        yr <- cloud_yrs[j]
        c_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(path.x)
        cat("Classifying...", basename(c_n), "\n")
        p_n <- jdf %>%
          dplyr::filter(year == yr - 1) %>%
          dplyr::pull(pathnew)#bring in classified image
        # current cloudy raster
        c_rst <- raster::raster(c_n)
        # classify it
        c_rst_c <- raster::reclassify(c_rst, cl)
        # previously already classified yr
        p_rst <- raster::raster(p_n)
        # stack it
        st <- raster::stack(p_rst, c_rst_c)
        # now clean up based on prior image
        clean_rst <- raster::overlay(st, fun = cldfun2)
        o_n <- jdf %>%
          dplyr::filter(year == yr) %>%
          dplyr::pull(pathnew)
        raster::writeRaster(x = clean_rst, filename = o_n, datatype = "INTU",
                            overwrite = TRUE)
      }
    }
  })
}

#' A function to calculate vegetation classification area for reporting.
#'
#'  \code{veg_class_area} calculates classified areas.
#'
#' @details This function is designed to calculate the area of each class as
#'     defined by using the \code{\link{veg_class}} per reporting area or site.
#'     Reporting areas are defined by input shape file. Output results to csv.
#'
#' @param irast Character file path to input veg density rasters that have been
#'     through the veg classification process, i.e. those that are found in
#'     `veg_class_cloud_prob\` or `veg_class\`.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param iregions Character file path to a shape file (including extension)
#'     that defines reporting regions. The shape file should have an attribute
#'     column that defines the overall reporting "region" plus "site", if
#'     applicable, such as "NatPark_site1", "NatPark_site2" etc. The underscore
#'     delineates region from site.
#' @param attribname Character string of the name of the attribute column that
#'     contains the region information.
#'
#' @param areaname Character string of desired monitoring area name for inclusion
#'     to output csv name.
#'
#' @return Calculated areas are exported via csv file to `extent_summaries\`.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' veg_class_area(irast = "./veg_class_cloud_prob", rastkey = ".tif",
#'     iregions = "./vectors/regions.shp", attribname = "regions",
#'     areaname = "NKMP_all")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls
#' @importFrom stringr str_split
#' @importFrom terra rast vect res rasterize mask freq
#' @importFrom purrr map_df
#' @importFrom readr write_csv
#'
#' @export
veg_class_area <- function(irast, rastkey, iregions, attribname, areaname){
  suppressWarnings({
    irs <- fs::dir_ls(irast, glob = paste0("*", rastkey, "$"))
    rastdf <- dplyr::tibble(path = irs) %>%
      dplyr::mutate(yr = readr::parse_number(basename(path))) #%>%
    #dplyr::filter(!yr %in% dummies)
    regions <- terra::vect(iregions)
    reps <- unique(regions[[attribname]][[1]])
    # output folder
    out <- "./extent_summaries"
    if (!file.exists(out)) {dir.create(out)}
    # stack rasters
    rsk <- terra::rast(rastdf[[1]])
    # find pixel res and calculate hectares
    res_mult <- (round(terra::res(rsk)[1])^2)/10000
    stats <- dplyr::tibble()
    cat("Calculating veg classes... \n")
    for(i in seq_along(reps)){
      rep_i <- regions[i, attribname]
      cat("Doing...", reps[i], "\n")
      name_r <- stringr::str_split(reps[i], "_")[[1]][1]
      name_s <- stringr::str_split(reps[i], "_")[[1]][2]
      # make raster mask
      # rep_ir <- fasterize::fasterize(sf = rep_i, raster = rsk[[1]])
      rep_ir <- terra::rasterize(x = rep_i, y = rsk[[1]])
      # mask out
      # msk_ir <- raster::mask(x = rsk, mask = rep_ir)
      msk_ir <- terra::mask(rsk, rep_ir)
      names(msk_ir) <- rastdf[[2]]
      # calc freq table on stack
      # stk <- raster::freq(msk_ir)
      stk <- terra::freq(msk_ir, usenames = TRUE)
      # sensible stack names
      # s_layer_names <- paste0(sapply(stringr::str_split(basename(rastdf[[1]]), "_"), "[[", 1), "_",
      #                         rastdf[[2]])
      # names(stk) <- s_layer_names
      # area outputs
      out_df <- stk %>%
        # purrr::map_df(~ as.data.frame(.x), .id = "id") %>%
        dplyr::mutate(Region = name_r,
                      Site = name_s,
                      Area = count * res_mult,
                      DensityClass = case_when(
                        value == 1 ~ '10-19%',
                        value == 2 ~ '20-29%',
                        value == 3 ~ '30-49%',
                        value == 4 ~ '50-69%',
                        value == 5 ~ '70-100%',
                        value == 6 ~ 'Cloud',
                        value == 11 ~ 'Cloud 10-19%',
                        value == 12 ~ 'Cloud 20-29%',
                        value == 13 ~ 'Cloud 30-49%',
                        value == 14 ~ 'Cloud 50-69%',
                        value == 15 ~ 'Cloud 70-100%',
                        TRUE ~ "Other"
                      ),
                      Habitat = case_when(
                        value == 1 ~ "Very Sparse Mangroves",
                        value >= 2 & value <= 5 ~ "Mangroves",
                        value == 6 ~ "Cloud",
                        value == 11 ~ "Cloud likely Very Sparse Mangroves",
                        value >= 12 & value <= 15 ~ "Cloud likely Mangrove",
                        TRUE ~ "Other"
                      ),
                      Density = case_when(
                        value == 1 ~ "Very Sparse",
                        value == 2 ~ "Sparse",
                        value == 3 ~ "Sparse - Medium",
                        value == 4 ~ "Medium - Dense",
                        value == 5 ~ "Dense",
                        value == 6 ~ "Cloud",
                        value == 11 ~ "Cloud likely Very Sparse",
                        value == 12 ~ "Cloud likely Sparse",
                        value == 13 ~ "Cloud likely Sparse - Medium",
                        value == 14 ~ "Cloud likely Medium - Dense",
                        value == 15 ~ "Cloud likely Dense",
                        TRUE ~ "Other")) %>%
        dplyr::rename(Year = layer) %>%
        dplyr::select(-count, -value)
      stats <- dplyr::bind_rows(stats, out_df)
    }
    # find start end year
    ayrs <- unique(stats$Year)
    yrs <- paste0("_", min(ayrs), "-", max(ayrs), "_")
    # park
    park <- areaname
    # output name
    oname <- paste0(out, "/", park, yrs, "extent_summaries.csv")
    readr::write_csv(stats, path = oname)
  })
}


#' A function for calculating trend and trend class images
#'
#'  \code{trend_class} creates trend and trend class rasters from user specified
#'      time periods.
#'
#' @details Given an end year and a period length this function stacks the
#'     appropriate annual rasters and outputs a linear trend raster and a trend
#'     class raster based on a user supplied classification in csv format. The
#'     csv must have the following three column format so that each row forms a
#'     bin:
#' \itemize{
#'   \item lower - numerical low value for bin
#'   \item upper - numerical high value (<=) for bin
#'   \item reclass - numerical classification value
#'   }
#'     This classification is based on binning the slope values from the
#'     regression and is therefore sensitive to the period length. Ensure that
#'     the classification matches the intended period of analysis.
#'
#'     Note to accommodate any missing annual rasters, due to for example
#'     availability of suitable imagery, the function will create "dummy"
#'     rasters to pad the stack accordingly. These "dummy" rasters ensure the
#'     time variable is handled correctly in the regression. These "dummies" are
#'     deleted as the function cleans up after itself.
#'
#' @param irast Character file path to input veg density rasters that have been
#'     masked and found in either `veg_dens_mskd\` or `veg_dens_mskd_cld\`.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap).
#' @param end Numeric denoting final year of analysis.
#' @param period Numeric denoting intended length of trend analysis. Note that
#'     periods are matched to class bins so ensure that appropriate period
#'     length is entered otherwise results will be meaningless.
#' @param classes Character representation of the name of the trend class
#'     csv file including file path.
#'
#' @return A raster of slope values and a raster of trend classes are written to
#'     `trend_class\` for the intended period of analysis.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' trend_class(irast = "./veg_dens_mskd_for_trends", rastkey = ".tif",
#'     end = 2009, period = 10, classes = "./supplementary/trend_classes.csv")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls file_delete
#' @importFrom readr parse_number read_csv
#' @importFrom raster raster writeRaster stack nlayers calc reclassify
#' @importFrom stringr str_split str_replace
#'
#' @export
trend_class <- function(irast, rastkey, end, period, classes){
  suppressWarnings({
    ## Check for missing years...create dummies if required
    # get available raster names
    irs1 <- fs::dir_ls(irast, glob = paste0("*", rastkey, "$"))
    rastdf <- dplyr::tibble(path = as.character(irs1)) %>%
      dplyr::mutate(yr = readr::parse_number(basename(path)))
    # make generic raster name
    rstring <- irs1[[1]]
    numzap <- readr::parse_number(basename(rstring))
    gstring <- gsub(numzap, "XX", rstring)
    # find expected period
    start <- (end - (period - 1))
    true_period <- start:end
    # make an expected raster df
    dumdf <- dplyr::tibble(yr = true_period) %>%
      dplyr::mutate(path = stringr::str_replace(gstring, "XX", as.character(yr)))
    # df of missing rasters
    dum_rst <- dplyr::setdiff(dumdf, rastdf)
    # empty dummy raster
    blank <- raster::raster(irs1[1]); blank[] <- NA
    # write out dummy ratsers if required
    if(nrow(dum_rst) > 0){
      cat("Dealing with dummy years... \n")
      for(i in seq_along(dum_rst[[2]])){
        nname <- dum_rst[[2]][i]
        raster::writeRaster(blank, nname, datatype = 'INT1U', overwrite = TRUE)
      }
    } else {
      cat("No missing years... \n")
    }

    cat("Doing trends now... \n")

    irs2 <- fs::dir_ls(irast, glob = paste0("*", rastkey, "$"))
    # make stack and sensible names
    stk <- raster::stack(irs2)
    s_layer_names <- readr::parse_number(basename(irs2))
    names(stk) <- s_layer_names
    # subset stack
    stk_e <- grep(pattern = end, names(stk))
    stk_s <- stk_e - (period - 1)
    trnd_stk <- stk[[stk_s:stk_e]]
    # output folder
    out <- "./trend_class"
    if (!file.exists(out)) {dir.create(out)}
    # per pixel lm
    time <- 1:raster::nlayers(trnd_stk)
    c_off <- ceiling(length(time)/2) # min data for lm choice
    lin_fun <- function(x) {
      if (sum(is.na(x)) > c_off) {
        NA
      } else {
        m = lm(x ~ time)
        m$coefficients[2]
      }
    }
    trend <- raster::calc(trnd_stk, lin_fun)
    # get classes
    cl <- as.matrix(readr::read_csv(classes))
    # reclassify to trend class
    trnd_cl <- raster::reclassify(trend, cl)
    # name and save
    ayrs <- readr::parse_number(names(trnd_stk))
    yrs <- paste0("_", min(ayrs), "-", max(ayrs), "_")
    park <- unlist(stringr::str_split(basename(irs2[1]), "_"))[1]
    oname <- paste0(out, "/", park, "_mangroves", yrs, "trendclass.img")
    tname <- paste0(out, "/", park, "_mangroves", yrs, "trend.img")
    raster::writeRaster(trnd_cl, filename = oname, datatype = 'INT1U',
                        overwrite = TRUE)
    raster::writeRaster(trend, filename = tname, datatype = 'FLT4S',
                        overwrite = TRUE)
    ##Removal of dummies
    if(nrow(dum_rst) > 0){
      cat("Removing dummies... \n")
      for(i in seq_along(dum_rst[[2]])){
        tozap <- fs::dir_ls(irast, regexp = dum_rst[[2]][i])
        fs::file_delete(tozap)
      }
    } else {
      cat("No dummies to remove... \nAll finished... \n")
    }

  })
}

#' A function to calculate trend class classification area for reporting.
#'
#'  \code{change_extent} creates area stats for previously generated trend class
#'      rasters.
#'
#' @details This function is designed to calculate the area of each trend class
#'     as defined by using the \code{\link{trend_class}} per reporting area or
#'     site.Reporting areas are defined by input shape file. Outputs results to
#'     csv.
#'
#' @param irast Character file path to the trend class raster for a distinct period
#'     that has been written to the `trend_class\` directory. If multiple periods
#'     (and rasters) exist, run this one at a time.
#' @param iregions Character file path to a shape file (including extension)
#'     that defines reporting regions. The shape file should have an attribute
#'     column that defines the overall reporting "region" plus "site", if
#'     applicable, such as "NatPark_site1", "NatPark_site2" etc. The underscore
#'     delineates region from site.
#' @param attribname Character string of the name of the attribute column that
#'     contains the region information.
#'
#' @return Calculated areas are exported via csv file to `trend_class\`.
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' trend_class_areas(irast = "./trend_class/LgCSMP_mangroves_2005-2009_trendclass.img",
#'     iregions = "./vectors/regions.shp", attribname = "regions")
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom sf st_read
#' @importFrom raster raster mask extension freq
#' @importFrom stringr str_split
#' @importFrom fasterize fasterize
#' @importFrom tibble as_tibble
#' @importFrom readr write_csv
#'
#' @export

trend_class_area <- function(irast, iregions, attribname){
  suppressWarnings({
    regions <- sf::st_read(iregions)
    reps <- unique(regions[[attribname]])
    # trendclass raster
    tcs <- raster::raster(irast)
    # find pixel res and calculate hectares
    res_mult <- (round(raster::res(tcs)[1])^2)/10000
    out_list <- list()
    for(i in seq_along(reps)){
      # monitoring vector
      rep_i <- regions[i, attribname]
      name_r <- stringr::str_split(reps[i], "_")[[1]][1]
      name_s <- stringr::str_split(reps[i], "_")[[1]][2]
      cat(paste0("working on ", name_s, "...\n"))
      # make raster mask
      rep_ir <- fasterize::fasterize(sf = rep_i, raster = tcs)
      # mask out
      msk_ir <- raster::mask(x = tcs, mask = rep_ir)
      # calc freq
      stats <- tibble::as_tibble(raster::freq(msk_ir)) %>%
        dplyr::filter(!is.na(value)) %>%
        dplyr::mutate(Region = name_r,
                      Site = name_s,
                      Area = count * res_mult,
                      TrendClass = case_when(
                        value == 1 ~ "Major Gain",
                        value == 2 ~ "Minor Gain",
                        value == 3 ~ "Stable",
                        value == 4 ~ "Minor Loss",
                        TRUE ~ "Major Loss"
                      )) %>%
        dplyr::select(-value, -count)
      out_list[[i]] <- stats
    }
    # output
    out_df <- do.call("rbind", out_list)
    o_name <- gsub(raster::extension(irast), "_area_stats.csv", irast)
    readr::write_csv(out_df, path = o_name)

  })
}

#' A function to calculate change extent area and generate change rasters for
#' reporting.
#'
#'  \code{change_extent} creates change rasters between all consecutive  vegetation
#'      classification rasters and summary area stats.
#'
#' @details This function is designed to do two things:
#'  \itemize{
#'   \item Firstly it creates change rasters between consecutive vegetation
#'       classification raster as produced by running \code{\link{veg_class}}. It
#'       summarises the densities into loss gain and stable categories in the
#'       output rasters.
#'   \item Secondly it generates area stats for regions and sites, defined by a
#'       user's shape file.
#'   }
#'
#' @param irast Character file path to input veg density rasters that have been
#'     through the veg classification process, i.e. those that are found in
#'     `veg_class\`.
#' @param rastkey Character representation of unique string to match in intended
#'     rasters. This aids in not selecting additional files generated by other
#'     software (e.g. ArcMap). It will also be the output format of any rasters.
#' @param iregions Character file path to a shape file (including extension)
#'     that defines reporting regions. The shape file should have an attribute
#'     column that defines the overall reporting "region" plus "site", if
#'     applicable, such as "NatPark_site1", "NatPark_site2" etc. The underscore
#'     delineates region from site.
#' @param attribname Character string of the name of the attribute column that
#'     contains the region information.
#' @param cloud Logical. Default is FALSE. If input imagery has  undergone
#'     groveR cloud masking choose TRUE. Can add significant processesing time
#'     on very large rasters.
#'
#'
#' @return Rasters and calculated areas are exported to `extent_change\`.
#'
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' @examples
#' \dontrun{
#' change_extent(irast = "./veg_class", rastkey = ".img",
#'     iregions = "./vectors/regions.shp", attribname = "regions",
#'     cloud = FALSE)
#' }
#'
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom fs dir_ls
#' @importFrom readr  write_csv
#' @importFrom stringr str_replace str_split
#' @importFrom sf st_as_sf st_area st_drop_geometry st_write
#' @importFrom terra rast vect crop rasterize mask classify ifel
#' @importFrom units set_units
#'
#' @export
change_extent <- function(irast, rastkey, iregions, attribname, cloud = FALSE){
  irs <- rev(fs::dir_ls(irast, glob = paste0("*",
                                             rastkey, "$")))
  cdate <- Sys.Date()
  rastdf <- dplyr::tibble(path = irs) %>%
    dplyr::mutate(yr = readr::parse_number(basename(path))) %>%
    dplyr::mutate(pathnew = stringr::str_replace(path, "veg_class", "extent_change"),
                  pathnew1 = stringr::str_replace(pathnew, "Veg_Class", "extent_change_"),
                  pathnew2 = stringr::str_replace(pathnew1, rastkey, paste0(yr - 1, rastkey)))
  end <- length(rastdf[[1]]) - 1
  rcl <- c(0, 1, 1,
           1, 5, 2,
           5, 6, 6,
           6, 11, 7,
           11, 15, 8,
           15, Inf, NA)
  rclm <- matrix(rcl, ncol = 3, byrow = TRUE)
  out <- "./extent_change"
  if (!file.exists(out)) {
    dir.create(out)
  }
  # stack up
  whole_stack <- terra::rast(rastdf[['path']])
  # using vect to play with terra
  regions <- terra::vect(iregions)

  reps <- unique(regions[[attribname]][[1]])
  stats <- dplyr::tibble()
  # outer loop - by shape file reporting region
  for(i in seq_along(reps)){
    todo <- reps[i]
    rep_i <- regions[i, attribname]
    #crop and mask
    mini_crp <- terra::crop(whole_stack, rep_i)
    msk_i <- terra::rasterize(rep_i, mini_crp)
    min_msk <- terra::mask(mini_crp, msk_i)
    # inner loop - by year combo from mini stack
    for(j in 1:end){
      cat("Calculating change between...", rastdf[[2]][j],
          "and", rastdf[[2]][j + 1], " for ", todo,"\n")
      # get correct layers from stack
      b1 <- min_msk[[j]] #recent
      a1 <- min_msk[[j + 1]] #past

      # reclassify
      b <- terra::classify(b1, rclm)
      a <- terra::classify(a1, rclm)

      # shorten calcs if no cloud probabilities
      if(cloud == TRUE){
        # conditional statements
        a10 <- terra::ifel(a==1 & b==2 | is.na(a) & b==2, 10, 0)
        a11 <- terra::ifel(a==2 & b==1 | a==2 & is.na(b), 11, 0)
        a12 <- terra::ifel(a==2 & b==2, 12, 0)
        a13 <- terra::ifel(a==7 & b==2 | a==1 & b==8 | a==6 & b==8 | a==7 & b==8 | is.na(a) & b==8, 13, 0)
        a14 <- terra::ifel(a==8 & b==1 | a==8 & b==6 | a==2 & b==7 | a==8 & b==7 | a==8 & is.na(b), 14, 0)
        a15 <- terra::ifel(a==8 & b==2 | a==2 & b==8 | a==8 & b==8, 15, 0)
        a16 <- terra::ifel(a==6 & b==2 | a==2 & b==6, 16, 0)
        ext_chng <- a10+a11+a12+a13+a14+a15+a16
        ext_chng <- terra::ifel(ext_chng != 0, ext_chng, NA)
      } else {
        # conditional statements
        a10 <- terra::ifel(a==1 & b==2 | is.na(a) & b==2, 10, 0)
        a11 <- terra::ifel(a==2 & b==1 | a==2 & is.na(b), 11, 0)
        a12 <- terra::ifel(a==2 & b==2, 12, 0)
        ext_chng <- a10+a11+a12
        ext_chng <- terra::ifel(ext_chng != 0, ext_chng, NA)
      }

      # convert raster output to shp and also calc areas
      v_chng <- terra::as.polygons(ext_chng) |>
        sf::st_as_sf()
      names(v_chng) <- c("gridcode", "geometry")
      au <- units::set_units(sf::st_area(v_chng), ha)
      period <- paste0(rastdf[[2]][j], "-", rastdf[[2]][j + 1])
      name_v <- paste0(out, "/", todo, "_", period, ".shp")
      v_dat_xy <- v_chng |>
        dplyr::mutate(status = case_when(
          gridcode == 10 ~ "gain",
          gridcode == 11 ~ "loss",
          gridcode == 12 ~ "stable",
          gridcode == 13 ~ "cloud likely gain",
          gridcode == 14 ~ "cloud likely loss",
          gridcode == 15 ~ "cloud likely stable",
          gridcode == 16 ~ "cloud no data",
          TRUE ~ "other"
        )) |>
        dplyr::mutate(area_ha = au) |>
        sf::st_write(dsn = name_v)

      # names
      name_r <- stringr::str_split(todo, "_")[[1]][1]
      name_s <- stringr::str_split(todo, "_")[[1]][2]

      # shape file to df for stats
      v_dat_df <- v_dat_xy |>
        sf::st_drop_geometry() |>
        dplyr::mutate(Region = name_r,
                      Site = name_s,
                      Period = period) |>
        dplyr::select(Region, Site, area_ha, status, Period) |>
        dplyr::rename(Area_ha = area_ha,
                      Status = status) |>
        dplyr::mutate(Area_ha = as.numeric(Area_ha))

      stats <- dplyr::bind_rows(stats, v_dat_df)


    }
  }
  # out put stats
  tofind <- tail(strsplit(rastdf[[4]][1], "_")[[1]],
                 n = 1)
  cname <- stringr::str_replace(rastdf[[4]][1], tofind,
                                paste0(cdate, ".csv"))
  readr::write_csv(stats, file = cname)
}
